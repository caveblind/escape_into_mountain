"""
Beau Albritton
CS2300

main.py for Spotify Album Search webapp

"""

#Importing dependencies and specific methods.
#See documentation for Spotify Dev API, Flask and Spotipy in README.md

#Render template automizes html files, allowing for dynamic programming with variables.
#Request gives flask the ability to access HTTPS requests and their corresponding data. 
#Redirects sends users to a new page in the website. 
from flask import Flask, redirect, render_template, request
#Importing spotipy enirely
import spotipy
#Need to use this to access API. Credentials contain an ID and "Secret" which is an access token.
#Configured these tokens to an app in the Spotify Web Dev environemnt 
#Also used my personal spotify credentials for this (not great practice)
from spotipy.oauth2 import SpotifyClientCredentials
#Need json for later review functionality. 
import json
#Timestamps
import datetime

app = Flask(__name__)

#Using my credentials for this from Spotify for Developers
client_id = "39cff5a6b7ab4f8792bc33395223c247"
client_secret = "2960b91248e543d097d07f5ed8b3eb5c"
#Setting the variable "spotify" to an object that contains a valid spotipy instance. This interfaces with the Spotify API directly
spotify = spotipy.Spotify(client_credentials_manager=SpotifyClientCredentials(client_id=client_id, client_secret=client_secret))

#Basic hompeage. 
@app.route('/')
def index():
    #Render template takes in an .html file based in the "/templates" directory. And renders it dynamically to the user's brwoser.
    return render_template('index.html')

#Routing to a new page "/search" which contains relevant information to the searched artist. 
# See index.html for further implementation
@app.route('/search', methods=['POST'])
def search():
    #Getting data from the form that was POSTed to the server.
    #Setting artist_name to the value that is assigned to 'artist'
    artist_name = request.form['artist']
    #Making a call to the Spotify API to search for an artist based on previous input
    #This returns a dictionary (python array) containing valid artist results
    results = spotify.search(q=artist_name, type='artist')
    
    #If artists name is empty, correct invalid input.
    #Unfortunately no more input validation is required since the Spotify API returns an artist that matches a character in the string. Usually the most popular. (Based on their private algorithm)
    #For example, typing "Led" will return the Artist "Led Zeppelin" or "a" will return "Ariana Grande"
    if artist_name.strip() == "":
        return render_template('results.html', error="Invalid input")
    else:
        #Checking to see if there are valid contents in the resulting search. If there aren't return no artists.
        #2D dictionary, so this artist has multiple items. Album list is one of them, so are popular songs.
        if results['artists']['items']:
            #Get the first index of the artist items, which is the artist itself. (Might be unintuitive but this works)
            artist = results['artists']['items'][0]
            #Setting id of the artist for searching 
            artist_id = artist['id']
            
            #Retrieving the specific *albums* under an artist's list. No singles, no EPs. Album specific (Would require further implementation )
            artist_albums = spotify.artist_albums(artist_id, album_type='album')
            #Now retrieving albums as a list relevant to all items under artist_albums (albums themselves.)
            #One thing I learned through this is that the Spotify API is sticky.
            albums = artist_albums['items']  
            
            # Using .json (javascript object notation) for reviews of an album. 
            with open('reviews.json', 'r') as file:
                #Setting the data in the reviews to an object loaded by the json module.
                reviews_data = json.load(file)
                
            #Now indexing through each individual album in the list. 
            #This will modify the retrieved albums data and add tracklists and reviews
            #Which will later be handled in results.html
            for album in albums:
                #Calling album_tracks which returns a list of tracks in an album. 
                track_list = spotify.album_tracks(album['id'])

                #Creating a new list in album, and setting that to the list of items in track_list (returned earlier)
                album['track_list'] = track_list['items']
                #Creating another list in album, this time from reviews.json, retrieving each review by
                #Specific album 'id' which is a unqiue hash of numbers generated by Spotify
                #This will later be compared in results.html so that only relevant reviews
                #Are posted to a specific album
                album['reviews'] = reviews_data['reviews'].get(album['id'], [])

            #Returns render template for results.html, sending the artist and albums obtained in the previous calls
            #To the html file for dynamic rendering.
            return render_template('results.html', artist=artist, albums=albums)
        else:
            #Pass the error variable through, which is handled in results.html. If there is an error, print it, else, do not.
            return render_template('results.html', error="No artist found")


#Form method for a users review submission.
@app.route('/submit_review', methods=['POST'])
def submit_review():
    #Looking for POST, which in this case methods is passed through as 'POST'
    #Otherwise, if their has not been a POSTed form, an error must have occured, so don't post a review.
    if request.method == 'POST':
        #Form data
        #Using request again to look for specific inputs from the user in the form.
        #Setting variables acccordingly
        album_id = request.form['album_id']
        album_name = request.form['album_name']
        username = request.form['username']
        score = float(request.form['score'])
        review_text = request.form['review_text']
        
        #Setting this review to a dictionary object containing multiple fields.  
        new_review = {
            "user": username,
            "score": score,
            "text": review_text,
            #Did not get a chance to implement this.
            #Either way, uses native datetime module and it's datetime class to get current timestamp.
            "date": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            #Actualy album name
            "album_name": album_name  
        }
        
        #Try catch method for opening json file
        try:
            #Opening json
            with open('reviews.json', 'r') as file:
                reviews_data = json.load(file)
            
            #If there is not a current review listed for album_id (from the user that submitted), then make a new review in the review data for later appending
            if album_id not in reviews_data['reviews']:
                reviews_data['reviews'][album_id] = []
            
            #Appending new review
            reviews_data['reviews'][album_id].append(new_review)
            
            #Writing json using the dump() method unqiue to json module
            with open('reviews.json', 'w') as file:
                json.dump(reviews_data, file, indent=4)
            
            #Redirect. This needs some proper fixing. 
            return redirect('/');
        #Catching whatever error was thrown and handling it accordingly, by sending an error to results.html.
        #No new review is posted
        except Exception as e:
            #Printing to the console 
            print(f"Error saving review: {str(e)}")
            #Returning error to results.html
            return render_template('results.html', error="Error saving review")

#Finally running the app.
if __name__ == '__main__':
    #Using localhost. Kept debug on if any errors arise that I didn't account for. Flask has built in traceback.
    app.run(debug=True, host= "localhost")
